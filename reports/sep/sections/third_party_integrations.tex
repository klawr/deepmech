\section{Third party integrations}

The web application has a lot of advantages.
First and foremost it is mostly operating system agnostic since it is available in every modern internet browser and available as a progressive web app.

A major disadvantage is that it is not as performant as other environments.
Especially the cropping of images for the preparation to the second model is taking a long time.
This part of the process is avoidable, by moving the inference process to a better performing environment\footnote{The browser implementation can be optimized of course, but local implementations should outperform browser implementations. }. % TODO back this up by evidence?

Other applications can take on tasks by registering themself to the web app.
If an app is registered is captured in the \code{extern} property in the state of the \code{deepmech} slice, as shown in Listing~\ref{lst:deepmech_slice}.
The \code{extern} property has four properties\footnote{Which is subject to change if the application is growing.}.
To register a third-party application, it is necessary to call the \code{register} action.
The \code{action.payload} depends on the respective third-party application.
At the moment three different third-party approaches are implemented.

\subsection{WPF and WinUI}

The Windows Presentation Foundation is a subsystem that can create user interfaces for windows applications.
The application is implemented using \name{C\#} and \name{XAML}.
It offers a \name{WebView2}\footnote{There is a WebView component, too, but it uses the now deprecated Microsoft Edge rendering engine. The \code{WebView2} component uses the \name{Chromium} engine.} control which embeds the web application into a native windows application.

The application is created by the template \name{WPF Application} of the \name{Visual Studio Community Edition 2019} with the official \name{.NET desktop development} workload installed.
This application template already impements everything necessary to compile an application.
The \code{MainWindow.xaml} will be the main page of the application.
The only window present in this application is the \code{WebView2} component\footnote{The content of the main window can be reviewed at \aka{https://github.com/klawr/deepmech/blob/master/src/wpf/deepmech/MainWindow.xaml}.}

The \code{WebView2} component itself is controlled by the \code{DeepmechHandler} property which is a \code{DeepmechWebView} object.
To register the \code{DeepmechHandler} a \code{Register} function is defined, which can be seen in Listing~\ref{lst:deepmech_webview_register}.

\begin{lstlisting}[label={lst:deepmech_webview_register}, caption={DeepmechWebView Register function}]
private string WebviewPlaceholder(string message)
    => "globalThis.webviewEventListenerPlaceholder(" + message + ")";

public void Register(canvas, prediction)
{
    WebView.ExecuteScriptAsync(WebviewPlaceholder(
        "{register:{canvas: false, prediction: true}}"));
}
\end{lstlisting}

The \code{WebviewPlaceholder} is used every time a message is send to the PWA, hence it is implemented as function to wrap the \code{message}.
The \code{WebView} is a property of the \code{DeepmechWebView} object and passed as argument constructor to be able to access the \code{WebView2} component from within the class.

\subsection{Interface to the PWA} \label{ch:interface_to_the_pwa}

The PWA has respective code in the \code{App} component to handle calls via an event listener.
This will be only activated if the \code{webview} property of the \code{chrome} object is defined, as can be seen in Listing~\ref{lst:chrome_webview_eventlistener}.
The \code{WebView2} component creates the \code{chrome.webview} property in the embedded web application.

\begin{lstlisting}[label={lst:chrome_webview_eventlistener}, caption={PWA event-handler for the chrome webview}]
if (globalThis.chrome?.webview) {
  dispatch(deepmechAction.initiate());

  globalThis.webviewEventListenerPlaceholder = (o) => {
    if (o.register) {
      dispatch(
        deepmechAction.register({
          canvas: o.register.canvas,
          prediction: o.register.prediction,
        })
      );
    }
    if (o.prediction) {
      dispatch(deepmechAction.updateModel(o.prediction));
    }
  };
}
\end{lstlisting}

This event-handler calls the \code{updateModel} function if the \code{prediction} property is set on the transfered object.

The prediction is called from within the \code{predict} action of the \code{DeepmechSlice}.
If the \code{extern.predict} property is set, the \code{predict} command will not issue a prediction in the web application itself, but will try to send messages to the first detected third-party implementation\footnote{There should be at most one active third-party implementation, otherwise this acts as a priority list.}.
The message sent consists of two properties:
\code{image} is a base64 representation of the canvas content, generated by \code{canvas.toDataURL().replace(/\^\ data:image.+;base64,/,"")}.
\code{nodes} contains the already existing nodes, with some processing to remove the cartesian modifier and remove the artificial 16 pixel offset created by the \code{updateNodes}\footnote{See \aka{https://github.com/klawr/deepmech/blob/gh-pages/src/deepmech/deepmech.js\#L277}.}.
The object is stringified by \code{JSON.stringify} and sent via the \code{postMessage} function of the \code{chrome.webview} object.

\subsection{Interface of the WPF}

The \code{WebView2} has an event-handler implemented to process messages that are sent via \code{chrome.webview.postMessage}.
This event handler is defined as \code{ProcessWebMessage} and can be used to implement a listener for messages sent via the website embdedded in \code{WebView2}.
The implementation of this event handler in the WPF can be seen in Listing~\ref{lst:wpf_event_handler}.

\begin{lstlisting}[label={lst:wpf_event_handler}, caption={Event handler of the WPF-application}]
public void ProcessWebMessage(
    object sender, CoreWebView2WebMessageReceivedEventArgs e)
{
    if (e.Source != WebView.Source.ToString()) //sender.Source.ToString()
    {
        return;
    }

    var message = JsonSerializer.Deserialize<DeepmechMessage>
        (e.TryGetWebMessageAsString());

    if (message == null) return;
    if (message.ready)
    {
        Register(canvas: false, prediction: true);
    }
    if (message.image != null)
    {
        Predict(Deepmech_cxx.Predict(
            Deepmech_ctx, message.image, message.nodes));
    }
}
\end{lstlisting}

Here it can be seen that \code{Register} from Listing~\ref{lst:deepmech_webview_register} is called when the PWA sends a message declaring it being ready for third-party applications to register.
The PWA sends this message by calling \code{deepmechAction.initate} which can be seen in Listing~\ref{lst:chrome_webview_eventlistener}.

If the \code{message} contains an \code{image} property\footnote{Which is the case when a prediction is requested} the \code{Predict} function is called.
The \code{Predict} function is very similar to the \code{Register} function, with the difference of having a \code{prediction} property in the message, instead of \code{register}.
The content of the \code{prediction} property is defined by the return value of \code{Deepmech\_cxx}'s \code{Predict} function.

\subsection{Predictions in C++}

There are implementations of TensorFlow in .NET\footnote{Examples being \aka{https://github.com/SciSharp/TensorFlow.NET} and \aka{https://github.com/migueldeicaza/TensorFlowSharp}}, but for the purpose of this implementation I decided to use an implementation in C++\footnote{The respective code can be reviewed at \aka{https://github.com/klawr/deepmech/blob/master/src/cxx/src/deepmech.cpp}.}.
Unfortunately, at the time of writing, the official TensorFlow API can not be used under the Windows operating System\footnote{The discussion regarding the issue can be read here \aka{https://github.com/tensorflow/tensorflow/issues/41904}.}, which is mandatory for \name{WPF} and \name{WinUI} applications.
As a substitution for this the \name{frugally-deep} library is used~\cite{Hermann2021}.

The created library exposes three functions:
\begin{enumerate}
    \item \code{create\_deepmech\_ctx} expects two c-style strings.
        The PWA uses \name{tensorflow.js} to load the model, as described in Chapter~\ref{ch:conversion_to_web_context}.
        For the implementation using \name{frugally-deep} a similar conversion is used, which is described at \aka{https://github.com/Dobiasd/frugally-deep\#usage}.
        After the conversion into a usable JSON file the contents can be passed to \code{create\_deepmech\_model} as c-style strings.
    \item \code{predict} expects a pointer to a \code{Deepmech\_ctx} instance, an image and its dimensions and a c-style string containing the known nodes in JSON format.
        The first parameter can be obtained by calling \code{create\_deepmech\_ctx}.
        The \code{image} is an integer array containing normalized values between 0 and 255 for the gray-scale information.
        Subsequentially \code{width} multiplied by \code{height} have to be equal to the length of this integer array. These variables are used by \name{OpenCV} to load the image.
    \item The application has no way of knowing if the return value of the \code{predict} function is longer needed.
        To compensate \code{deepmech\_cxx\_free} can be called to free the occupied memory.
    \item \code{destroy\_deepmech\_ctx} has the same function as \code{deepmech\_cxx\_free}, but refers to the \code{Deepmech\_ctx} object itself, which is called when an \code{DeepmechWebView} is disposed.
\end{enumerate}

The compiled \name{deepmech\_cxx.dll} is placed into the respective directory for the functions to be usable by the WPF-application.
The WPf-application has a static class dedicated to communicate with this library using imports as can be seen in Listing~\ref{lst:wpf_dll_imports}.

\begin{lstlisting}[label={lst:wpf_dll_imports}, caption={DllImports in the static Deepmech\_cxx class}]
[DllImport("deepmech_cxx")]
public static extern IntPtr create_deepmech_ctx(
    [MarshalAs(UnmanagedType.LPStr)] string symbolModel,
    [MarshalAs(UnmanagedType.LPStr)] string cropModel);

[DllImport("deepmech_cxx")]
private extern static IntPtr predict(
    IntPtr deepmech_ctx, byte[] imageData, uint width, uint height,
    [MarshalAs(UnmanagedType.LPStr)] string nodes);

[DllImport("deepmech_cxx")]
private extern static void deepmech_cxx_free(IntPtr str);

[DllImport("deepmech_cxx")]
public extern static void destroy_deepmech_ctx(IntPtr ctx);
\end{lstlisting}

These functions are called exclusively by the \code{DeepmechWebView} object; e.g. it creates the \code{Deepmech\_ctx} on construction.
The respective JSON-strings containing the inference models are imported and read from the \code{Properties.Resources} namespace, used by WPF-applications to import external resources.

When the \code{Deepmech\_cxx.Predict} function is called as in Listing~\ref{lst:wpf_event_handler} the pointer to the \code{Deepmech\_ctx}, the image and known nodes are submitted.

The base64 string is converted to an image using the \name{SixLabors.ImageSharp} library~\cite{SixLabors2021}, as seen in Listing~\ref{lst:deepmech_cxx_image_conversion}.

\begin{lstlisting}[label={lst:deepmech_cxx_image_conversion}, caption={Deepmech\_cxx overload for image conversion.}]
public static string Predict(
    IntPtr deepmech_ctx, string base64, string nodes = null)
    => Predict(deepmech_ctx,
               Image.Load<A8>(Convert.FromBase64String(base64)),
               nodes);
\end{lstlisting}

The overloaded \code{Predict} function in \code{Deepmech\_cxx} calls the imported \code{predict} function and returns the resulting c-style string.
The return value is already in JSON-format and converted to a C\# string by \code{Marshal.PtrToStringUTF8(resultNativeString)}.
This is subsequentially returned and then sent to the PWA, as seen in Listing~\ref{lst:wpf_event_handler}.

The known nodes are included in the inference, by transferring the known nodes as an integer array through this pipeline.
This is done to use them when creating the crops for the constraint detection.

The C++ implementation itself is a rewrite of the Python implementation similar to the conversion in Chapter~\ref{ch:conversion_to_web_context}.
It can be reviewed at \aka{https://github.com/klawr/deepmech/blob/master/src/cxx/src/deepmech.cpp}.

\subsection{Implementation in WinUI}

The WPF-application is working as a functional prototype, but unfortunately the referenced \name{Microsoft.Toolkit.Wpf.UI.Controls}\footnote{See the repository here: \aka{https://github.com/windows-toolkit/WindowsCommunityToolkit}.} extension is no longer supported in \name{.NET 5}\footnote{The respective discussion on the issue can be reviewed here \aka{https://github.com/windows-toolkit/Microsoft.Toolkit.Win32/issues/296}.}.
Because of this an older version of the extension is used already\footnote{The changes occured while working on the project.}.

Fortunately Microsoft offers other frameworks to publish applications.
The development of \name{WinUI 3} applications is very similar to WPF\footnote{I am sure more sophisticated developers knowing the intricate differences may disagree, but as most of the code can be reused they seem to be similar from my perspective}.

With the exception of some namespaces the source code of the WinUI implementation is the same, which can be seen here \aka{https://github.com/klawr/deepmech/tree/master/src/winui}

\subsection{Webserver implementation}

Another way of getting better performance for the inference is to redirect the process to a webserver.
To register a local webserver, the \code{register} action of the \code{DeepmechSlice} reducer in the PWA can be issued.
It sets the \code{serverport} and the \code{prediction} properties of the \code{state.extern.prediction}.

When a prediction is issued a HTTP request is sent to the webserver.
The request \code{message} contains the same properties as the messages discussed in Chapter~\ref{ch:interface_to_the_pwa}.
The respective fetch request and subsequent response handling can be seen in Listing~\ref{lst:predict_http_request}.

\begin{lstlisting}[label={lst:predict_http_request}, caption={Communication of PWA via HTTP.}]
fetch("http://localhost:" + port, {
    method: "POST",
    body: JSON.stringify(message),
    headers: new Headers({
        "Content-Type": "application/json",
    }),
}).then((r) => {
    const reader = r.body.getReader();
    reader.read().then(({ done, value }) => {
        updateModel(JSON.parse(String.fromCharCode(...value)));
    });
});
\end{lstlisting}

To register the webserver a new button is implemented to the \code{LeftDrawer} component, which will dispatch the respective \code{register} action. 

The prediction functionality of the webserver is using the already existing Python implementation, introduced in Chapter~\ref{ch:combine_node_constraint_detection}
\footnote{The corresponding script can be seen at \aka{https://github.com/klawr/deepmech/blob/master/src/webserver/predict.py}.}.
The predict function is slightly modified to be able to handle the base64-encoded images provided by the PWA.
The function also expects a JSON-string containing information about the known nodes to be able to respect those in the constraint detection.

The webserver is implemented as a \code{DeepmechPredictionServer} class, which inherits from the \code{BaseHTTPRequestHandler} imported from the \code{http.server} package.
This class provides functions like \code{do\_OPTIONS}, \code{do\_GET} and \code{do\_PUSH}, corresponding to the standard HTTP requests \code{OPTIONS}, \code{GET} and \code{PUSH}.
\code{do\_Get} is used to show some text about this server to a user which is using the browser to get information about the server.
\code{do\_Options} and \code{do\_Post} provide the necessary headers to allow cross origin communcation\footnote{For more information about \name{CORS} see \aka{https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS}.}.

The server converts the results of the prediction into JSON-format and returns the response to the PWA, which updates the model accordingly as seen in Listing~\ref{lst:predict_http_request}.

