\section{Third party integrations}

The web application has many advantages.
First and foremost it is operating system agnostic since it is available in every modern internet browser and available as a progressive web app. % TODO link to PWA? 

A major disadvantage is that it is not as performant as other environments.
Especially the cropping of images for the preparation to the second model is taking a long time.
% TODO implement code here.
% TODO do some benchmarks

Other applications can take on tasks by registering themself to the web app.
If an app is registered is captured in the \code{extern} property in the state of the \code{deepmech} slice, as shown in Listing~\ref{lst:deepmech_slice}.
The \code{extern} property has four properties\footnote{Which is subject to change if the application is growing.}.
To register a third-party application function it is necessary to call the \code{register} action.
The \code{action.payload} depends on the respective third-party application.
At the moment three different third-party approaches are implemented.

\subsection{WPF and WinUI}

The Windows Presentation Foundation is a subsystem that can create user interfaces for windows applications.
It offers a \name{WebView2}\footnote{There is a WebView component, too, but it uses the now deprecated Microsoft Edge rendering engine.} control which embeds the web application into a native windows application. % TODO some context about WebView.
The app is generated by the template \name{WPF Application} of the \name{Visual Studio Community Edition 2019} with the official \name{.NET desktop development} workload installed.
In this app we find a \code{MainWindow.xaml} which will be the main page of the application.
As we only need the \code{WebView2} component, the only component  only consists that\footnote{The code of this component can be reviewed at \aka{https://github.com/klawr/deepmech/blob/master/sep/src/wpf/deepmech/MainWindow.xaml}.}

The \code{WebView2} component itself is controlled by the \code{DeepmechHandler} property which is a \code{DeepmechWebView} object\footnote{\aka{https://github.com/klawr/deepmech/blob/master/sep/src/wpf/deepmech/MainWindow.xaml}.}.
To register the \code{DeepmechHandler}, a \code{Register} function is exposed ,which can be seen in Listing~\ref{lst:deepmech_webview_register}.

\begin{lstlisting}[label={lst:deepmech_webview_register}, caption={DeepmechWebView Register function}]
private string WebviewPlaceholder(string message)
    => "globalThis.webviewEventListenerPlaceholder(" + message + ")";

public void Register(canvas, prediction)
{
    WebView.ExecuteScriptAsync(WebviewPlaceholder(
        "{register:{canvas: false, prediction: true}}"));
}
\end{lstlisting}

Whereas \code{WebviewPlaceholder} is used every time a message is send to the PWA, hence it is implemented as function to wrap the \code{message}.
The \code{WebView} is a property of the \code{DeepmechWebView} object and passed as argument constructor to be able to access the \code{WebView2} component from within the class.

The PWA has respective code in the \code{App} component to an event listener, if the \code{webview} property of the \code{chrome} object is defined, as can be seen in Listing~\ref{lst:chrome_webview_eventlistener}.
This \code{chrome.webview} property is only defined if a respective third-party created it.

\begin{lstlisting}[label={lst:chrome_webview_eventlistener}, caption={PWA event-handler for the chrome webview}]
if (globalThis.chrome?.webview) {
  dispatch(deepmechAction.initiate());

  globalThis.webviewEventListenerPlaceholder = (o) => {
    if (o.register) {
      dispatch(
        deepmechAction.register({
          canvas: o.register.canvas,
          prediction: o.register.prediction,
        })
      );
    }
    if (o.prediction) {
      dispatch(deepmechAction.updateModel(o.prediction));
   }
  };
}
\end{lstlisting}

This event-handler calls the \code{updateModel} function if the \code{prediction} property is set on the transfered object.

The prediction is called from within the \code{predict} action of the \code{DeepmechSlice}.
If the \code{extern.predict} property is set, the \code{predict} command will not issue a prediction in the PWA, but will try to send messages to all implemented third-party implementations.
The message sent consists of two properties:
\code{image} is a base64 representation of the canvas content, generated by \code{canvas.toDataURL().replace(/\^\ data:image.+;base64,/,"")}.
\code{nodes} contains the already existing nodes, with some processing to remove the cartesian effects and remove the artificial 16 pixel offset created by the prediction.
The object is stringified by \code{JSON.stringify} and sent via the \code{postMessage} function of the \code{chrome.webview} object.

The WPF-application also has a respecitve event-handler to process messages, which can be seen in Listing~\ref{lst:wpf_event_handler}.

\begin{lstlisting}[label={lst:wpf_event_handler}, caption={Event handler of the WPF-application}]
public void ProcessWebMessage(
    object sender, CoreWebView2WebMessageReceivedEventArgs e)
{
    // If the source is not validated, don't process the message.
    if (e.Source != WebView.Source.ToString()) //sender.Source.ToString()
    {
        return;
    }

    var message = JsonSerializer.Deserialize<DeepmechMessage>
        (e.TryGetWebMessageAsString());

    if (message == null) return;
    if (message.ready)
    {
        Register(canvas: false, prediction: true);
    }
    if (message.image != null)
    {
   Predict(Deepmech_cxx.Predict(Deepmech_ctx, message.image, message.nodes));
    }
}
\end{lstlisting}

Here we can examine that \code{Register} from Listing~\ref{lst:deepmech_webview_register} is called when the PWA sends a message declaring it being ready for third-party applications to register.
The PWA sends this message by calling \code{deepmechAction.initate} which can be seen in Listing~\ref{lst:chrome_webview_eventlistener}.

If the \code{message} contains an \code{image} property\footnote{Which is the case when a prediction is to be made}, the \code{Predict} funciton is called.
\code{DeepmechWebView}'s \code{Predict} function is very similar to the \code{Register} function, with the difference of having a \code{prediction} property in the message, instead of \code{register}.
The content of the \code{prediction} property is defined by the return value of \code{Deepmech\_cxx}'s \code{Predict} function.

% TODO check if this works offline.


% Write some text about WebView. How it uses chrome (inside the new edge and stuff.)

% Write something about the Python bindings. But maybe it is necessary to write Python as a server to avoid the startup lag.

