\section{Third party integrations}

The web application has many advantages.
First and foremost it is operating system agnostic since it is available in every modern internet browser and available as a progressive web app. % TODO link to PWA? 

A major disadvantage is that it is not as performant as other environments.
Especially the cropping of images for the preparation to the second model is taking a long time.
This part of the process is avoidable, by moving the workload to a better performing environment as the browser\footnote{The browser implementation can and should be optimized, too, but local implementations should outperform browser implementations. }. % TODO back this up by evidence?
% TODO do some benchmarks

Other applications can take on tasks by registering themself to the web app.
If an app is registered is captured in the \code{extern} property in the state of the \code{deepmech} slice, as shown in Listing~\ref{lst:deepmech_slice}.
The \code{extern} property has four properties\footnote{Which is subject to change if the application is growing.}.
To register a third-party application function it is necessary to call the \code{register} action.
The \code{action.payload} depends on the respective third-party application.
At the moment three different third-party approaches are implemented.

\subsection{WPF and WinUI}

The Windows Presentation Foundation is a subsystem that can create user interfaces for windows applications.
It offers a \name{WebView2}\footnote{There is a WebView component, too, but it uses the now deprecated Microsoft Edge rendering engine. The \code{WebView2} component uses the \name{Chromium} engine % TODO add citation or source?
.} control which embeds the web application into a native windows application.

The raw application is created by the template \name{WPF Application} of the \name{Visual Studio Community Edition 2019} with the official \name{.NET desktop development} workload installed.
This application consists of everything necessary to compile an application.
The \code{MainWindow.xaml} which will be the main page of the application.
The only window present in this application is the \code{WebView2} component\footnote{The content of the main window can be reviewed at \aka{https://github.com/klawr/deepmech/blob/master/sep/src/wpf/deepmech/MainWindow.xaml}.}

The \code{WebView2} component itself is controlled by the \code{DeepmechHandler} property which is a \code{DeepmechWebView} object\footnote{\aka{https://github.com/klawr/deepmech/blob/master/sep/src/wpf/deepmech/MainWindow.xaml}.}.
To register the \code{DeepmechHandler}, a \code{Register} function is exposed ,which can be seen in Listing~\ref{lst:deepmech_webview_register}.

\begin{lstlisting}[label={lst:deepmech_webview_register}, caption={DeepmechWebView Register function}]
private string WebviewPlaceholder(string message)
    => "globalThis.webviewEventListenerPlaceholder(" + message + ")";

public void Register(canvas, prediction)
{
    WebView.ExecuteScriptAsync(WebviewPlaceholder(
        "{register:{canvas: false, prediction: true}}"));
}
\end{lstlisting}

Whereas \code{WebviewPlaceholder} is used every time a message is send to the PWA, hence it is implemented as function to wrap the \code{message}.
The \code{WebView} is a property of the \code{DeepmechWebView} object and passed as argument constructor to be able to access the \code{WebView2} component from within the class.

\subsection{Interface to the PWA} \label{ch:interface_to_the_pwa}

The PWA has respective code in the \code{App} component to handle calls via an event listener.
This will be only activated, if the \code{webview} property of the \code{chrome} object is defined, as can be seen in Listing~\ref{lst:chrome_webview_eventlistener}.
The WPF-application uses the \code{chrome.webview} property, which is only defined if a respective third-party created it.

\begin{lstlisting}[label={lst:chrome_webview_eventlistener}, caption={PWA event-handler for the chrome webview}]
if (globalThis.chrome?.webview) {
  dispatch(deepmechAction.initiate());

  globalThis.webviewEventListenerPlaceholder = (o) => {
    if (o.register) {
      dispatch(
        deepmechAction.register({
          canvas: o.register.canvas,
          prediction: o.register.prediction,
        })
      );
    }
    if (o.prediction) {
      dispatch(deepmechAction.updateModel(o.prediction));
    }
  };
}
\end{lstlisting}

This event-handler calls the \code{updateModel} function if the \code{prediction} property is set on the transfered object.

The prediction is called from within the \code{predict} action of the \code{DeepmechSlice}.
If the \code{extern.predict} property is set, the \code{predict} command will not issue a prediction in the PWA, but will try to send messages to all implemented third-party implementations.
The message sent consists of two properties:
\code{image} is a base64 representation of the canvas content, generated by \code{canvas.toDataURL().replace(/\^\ data:image.+;base64,/,"")}.
\code{nodes} contains the already existing nodes, with some processing to remove the cartesian effects and remove the artificial 16 pixel offset created by the prediction.
The object is stringified by \code{JSON.stringify} and sent via the \code{postMessage} function of the \code{chrome.webview} object.

\subsection{Interface of the WPF}

The WPF-application has a respecitve event-handler to process messages, which can be seen in Listing~\ref{lst:wpf_event_handler}.

\begin{lstlisting}[label={lst:wpf_event_handler}, caption={Event handler of the WPF-application}]
public void ProcessWebMessage(
    object sender, CoreWebView2WebMessageReceivedEventArgs e)
{
    // If the source is not validated, don't process the message.
    if (e.Source != WebView.Source.ToString()) //sender.Source.ToString()
    {
        return;
    }

    var message = JsonSerializer.Deserialize<DeepmechMessage>
        (e.TryGetWebMessageAsString());

    if (message == null) return;
    if (message.ready)
    {
        Register(canvas: false, prediction: true);
    }
    if (message.image != null)
    {
        Predict(Deepmech_cxx.Predict(Deepmech_ctx, message.image, message.nodes));
    }
}
\end{lstlisting}

Here we can examine that \code{Register} from Listing~\ref{lst:deepmech_webview_register} is called when the PWA sends a message declaring it being ready for third-party applications to register.
The PWA sends this message by calling \code{deepmechAction.initate} which can be seen in Listing~\ref{lst:chrome_webview_eventlistener}.

If the \code{message} contains an \code{image} property\footnote{Which is the case when a prediction is requested}, the \code{Predict} function is called.
\code{DeepmechWebView}'s \code{Predict} function is very similar to the \code{Register} function, with the difference of having a \code{prediction} property in the message, instead of \code{register}.
The content of the \code{prediction} property is defined by the return value of \code{Deepmech\_cxx}'s \code{Predict} function.

\subsection{Predictions in C++}

There are implementations for TensorFlow for .NET\footnote{Examples being \aka{https://github.com/SciSharp/TensorFlow.NET} and  \aka{https://github.com/migueldeicaza/TensorFlowSharp}},
but for the purpose of this implementation I decided to use a implementation in C++\footnote{The respective code can be reviewed at \aka{https://github.com/klawr/deepmech/blob/master/src/cxx/src/deepmech.cpp}.}.
Unfortunately, at the time of writing, the official TensorFlow API can not be used under the Windows operating System\footnote{The discussion regarding the issue can be read here \aka{https://github.com/tensorflow/tensorflow/issues/41904}.}.
% TODO does github need a citation?
% TODO describe why Windows in necessary? Since I use WPF and WinUI...
As a substitution for this the \name{frugally-deep} library is used. % TODO citation needed

The created library exposes three functions:
\begin{enumerate}
    \item \code{create\_deepmech\_ctx} expects two c-style strings.
        The PWA uses \name{tensorflow.js} to load the model, as described in Chapter~\ref{ch:conversion_to_web_context}.
        For the implementation using \name{frugally-deep} a similar conversion is used, which is described at \aka{https://github.com/Dobiasd/frugally-deep\#usage}.
        After the conversion into a usable JSON file the contents can be passed to \code{create\_deepmech\_model} as c-style strings.
    \item \code{predict} expects a pointer to a \code{Deepmech\_ctx} instance, an image and its dimensions and a c-style string containing the known nodes in JSON format.
        The first parameter can be obtained by calling \code{create\_deepmech\_ctx}.
        The \code{image} is an integer array containing normalized values between 0 and 255 for the gray-scale information.
        Subsequentially \code{width} by \code{height} have to be equal to the length of this integer array and are used by \name{OpenCV} to load the image.
    \item The application has no way of knowing if the return value of the \code{predict} function is longer needed.
        To compensate \code{deepmech\_cxx\_free} can be called to free the occupied memory.
    \item \code{destroy\_deepmech\_ctx} has the same function as \code{deepmech\_cxx\_free}, but refers to the \code{Deepmech\_ctx} object itself, which is called automatically when an \code{DeepmechWebView} is disposed.
\end{enumerate}

The compiled \name{deepmech\_cxx.dll} is placed into the respective directory for the functions to be usable by the WPF-application.

The WPf-application has a static class dedicated to communicate with this library using imports as can be seen in Listing~\ref{lst:wpf_dll_imports}.

\begin{lstlisting}[label={lst:wpf_dll_imports}, caption={DllImports in the static Deepmech\_cxx class}]
[DllImport("deepmech_cxx")]
public static extern IntPtr create_deepmech_ctx(
    [MarshalAs(UnmanagedType.LPStr)] string symbolModel,
    [MarshalAs(UnmanagedType.LPStr)] string cropModel);

[DllImport("deepmech_cxx")]
private extern static IntPtr predict(
    IntPtr deepmech_ctx, byte[] imageData, uint width, uint height,
    [MarshalAs(UnmanagedType.LPStr)] string nodes);

[DllImport("deepmech_cxx")]
private extern static void deepmech_cxx_free(IntPtr str);

[DllImport("deepmech_cxx")]
public extern static void destroy_deepmech_ctx(IntPtr ctx);
\end{lstlisting}

These functions are called from the \code{DeepmechWebView} object, which creates the \code{Deepmech\_ctx} on construction.
The respective JSON strings containing the inference models are imported and read from the \code{Properties.Resources} namespace, used by WPF-applications to import external resources.

When the \code{Deepmech\_cxx.Predict} function is called as in Listing~\ref{lst:wpf_event_handler}, the pointer to the \code{Deepmech\_ctx} and the image and nodes are submitted.

The base64 string is converted to an image using the \name{SixLabors.ImageSharp} library, as seen in Listing~\ref{lst:deepmech_cxx_image_conversion}.% TODO citation needed

\begin{lstlisting}[label={lst:deepmech_cxx_image_conversion}, caption={Deepmech\_cxx overload for image conversion.}]
public static string Predict(IntPtr deepmech_ctx, string base64, string nodes = null)
    => Predict(deepmech_ctx, Image.Load<A8>(Convert.FromBase64String(base64)), nodes);
\end{lstlisting}

The overloaded \code{Predict} function in \code{Deepmech\_cxx} calls the imported \code{predict} function and returns the resulting c-style string in JSON format using \code{Marshal.PtrToStringUTF8(resultNativeString);}.
This is subsequentially returned and then sent to the PWA, as seen in Listing~\ref{lst:wpf_event_handler}.

The known nodes are included in the inference, by transferring the known nodes as an integer array through this pipeline.
This is done to use them when creating the crops for the constraint detection.

The C++ implementation itself is a rewrite of the Python implementation similar to the conversion in Chapter~\ref{ch:conversion_to_web_context}.

\subsection{Implementation in WinUI}

The WPF-application is working, but the referenced \name{Microsoft.Toolkit.Wpf.UI.Controls}\footnote{See the repository here: \aka{https://github.com/windows-toolkit/WindowsCommunityToolkit}.} extension is no longer supported in \name{.NET 5}\footnote{The respective discussion on the issue can be reviewed here \aka{https://github.com/windows-toolkit/Microsoft.Toolkit.Win32/issues/296}.}.
Because of this an older version of the extension is used.

Fortunately Microsoft offers other frameworks to publish applications.
The development of \name{WinUI 3} applications is very similar to WPF\footnote{I am sure more sophisticated developers knowing the intricate differences may disagree, but as most of the code can be reused they seem to be similar from my perspective}.

With the exception of some namespaces the source code is the same, which can be seen here \aka{https://github.com/klawr/deepmech/tree/master/src/winui}

\subsection{Webserver implementation}

Another way of getting better performance for the inference is to redirect the process to a webserver.
To register a local webserver, the \code{register} action of the \code{DeepmechSlice} reducer in the PWA can be issued.
It sets the \code{serverport} and the \code{prediction} properties of the \code{state.extern.prediction}.

When a prediction is issued a HTTP request is sent to the webserver.
The request \code{message} contains the same properties as the messages discussed in Chapter~\ref{ch:interface_to_the_pwa}.
The respective fetch request and subsequent response handling can be seen in Listing~\ref{lst:predict_http_request}.

\begin{lstlisting}[label={lst:predict_http_request}, caption={Communication of PWA via HTTP.}]
fetch("http://localhost:" + port, {
    method: "POST",
    body: JSON.stringify(message),
    headers: new Headers({
        "Content-Type": "application/json",
    }),
}).then((r) => {
    const reader = r.body.getReader();
    reader.read().then(({ done, value }) => {
        updateModel(JSON.parse(String.fromCharCode(...value)));
    });
});
\end{lstlisting}

To register the webserver, a new button is implemented to the \code{LeftDrawer} component, which will dispatch the respective \code{register} action. 

The prediction functionality of the webserver is using the already existing Python implementation, introduced in Chapter~\ref{ch:combine_node_constraint_detection}
\footnote{The corresponding script can be seen at \aka{https://github.com/klawr/deepmech/blob/master/src/webserver/predict.py}.}.
The predict function is slightly modified to be able to handle the base64 encoded images provided by the PWA.
The function also expects a JSON string containing information about the known nodes to be able to respect those in the constraint detection.

The webserver is implemented as a \code{DeepmechPredictionServer} class, which inherits from the \code{BaseHTTPRequestHandler} imported from the \code{http.server} package.
This class provides functions like \code{do\_OPTIONS}, \code{do\_GET} and \code{do\_PUSH}, corresponding to the standard HTTP requests \code{OPTIONS}, \code{GET} and \code{PUSH}.
\code{do\_Get} is used to show some text about this server to a user which is using the browser to get some information about the server.
\code{do\_Options} and \code{do\_Post} provide the necessary headers to allow cross origin communcation\footnote{For more information about \name{CORS} see here: \aka{https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS}.}.

When the prediction is done, the server converts the results into JSON-format and returns the response to the PWA.
It can be seen in Listing~\ref{lst:predict_http_request} that the result will be used to update the mec-model.

